---
title: "clustSIGNAL tutorial"
author:
  - Pratibha Panwar, Boyi Guo, Haowen Zhou, Stephanie Hicks, Shila Ghazanfar
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
package: clustSIGNAL
vignette: |
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{clustSIGNAL tutorial}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  warning = FALSE
  )
```

# Overview

In this vignette, we will demonstrate how to perform spatially-resolved 
clustering with clustSIGNAL. Following this, we will explore the clusters using 
pre-defined metrics like adjusted rand index (ARI), normalised mutual 
information (NMI), and average silhouette width, as well as spatial plots. We 
will also display the use of entropy measures generated as a by-product of 
clustSIGNAL process in understanding the tissue structure of a sample. In the 
end, we will also explore multisample analysis with clustSIGNAL.

```{r load_packages, message = FALSE, warning = FALSE}
# load required packages
library(clustSIGNAL)
library(distances)
library(cluster)
library(aricode)
library(dplyr)
library(ggplot2)
library(patchwork)
library(scattermore)
library(scater)
```

# Single sample analysis with clustSIGNAL

Here, we use the SeqFISH mouse embryo dataset from [Lohoff et al, 2021](https://www.nature.com/articles/s41587-021-01006-2)
, which contains spatial transcriptomics data from 3 mouse embryos, with 351 
genes and a total of 57,536 cells. For this vignette, we subset the data by 
randomly selecting 5000 cells from Embryo 2, excluding cells that were manually 
annotated as 'Low quality'.

We begin by creating a SpatialExperiment object from the gene expression and 
cell information in the data subset, ensuring that the spatial coordinates are 
stored in spatialCoords within the SpatialExperiment object. If the data are 
already in a SpatialExperiment object, then the user can directly run 
clustSIGNAL, after ensuring that the basic requirements like spatial coordinates 
and normalized counts are met.

```{r embryo_data_prep}
data(mEmbryo2)
# this will load me_expr and me_data objects, containing gene expression 
# logcounts and cell metadata, respectively, to your environment
# to create a SpatialExperiment object we need gene expression, cell metadata, 
# and cell locations
spe <- SpatialExperiment(assays = list(logcounts = me_expr), colData = me_data,
                         # spatialCoordsNames requires column names in 
                         # me_data that contain xy-coordinates of cells
                         spatialCoordsNames = c("X", "Y"))
spe
```

For running clustSIGNAL, we need to know the column names in colData of the 
SpatialExperiment object that contain the sample and cell labels. Here, the 
sample labels are in the 'sample_id' column, and the cell labels are in the 
'uniqueID' column.

```{r embryo_data_columns}
spe |> colData() |> colnames() # to list the column names in the metadata
```

# Running clustSIGNAL on one sample

Next, we run clustSIGNAL using the sample and cell labels we identified earlier. 
The simplest clustSIGNAL run requires a SpatialExperiment object, two variables 
holding colData column names containing sample and cell labels, and the type of 
output the user would like to see. Other parameters that can be modified include 
dimRed to specify the low dimension data to use, batch to perform batch 
correction, batch_by to indicate sample batches contributing to batch effect, 
NN to specify the neighbourhood size, kernel for weight distribution to use, 
spread for distribution spread value, sort to sort the neighbourhood, threads 
to specify the number of cpus to use in parallel runs, and clustParams to 
specify clustering parameters.

Furthermore, the adaptively smoothed gene expression data generated by 
clustSIGNAL could be useful for other downstream analyses and will be 
accessible to the user if they choose to output the final SpatialExperiment 
object.

```{r clustSIGNAL_singleRun}
set.seed(100) # for reproducibility
samples <- "sample_id" # column name containing sample names
cells <- "uniqueID" # column name containing cell IDs
# the simplest run of clustSIGNAL requires data in a SpatialExperiment object,
# with column names for sample and cell labels specified, along with the type
# of output to generate (clusters, neighbours, and/or final spe object).
res_emb <- clustSIGNAL(spe, samples, cells, outputs = "a") 
```

This returns a list that can contain a dataframe of cluster names, a matrix of 
cell labels from each region's neighbourhood, a final SpatialExperiment object, 
or a combination of these, depending on the choice of 'outputs' selected. Here,
the output contains all three data types.

```{r embryo_result_list}
res_emb |> names() # listing the names of the outputs generated
```

The cluster dataframe contains cell labels and their cluster numbers allotted 
by clustSIGNAL.

```{r embryo_clusters_head}
res_emb$clusters |> head() # cluster data frame has cell IDs and cluster labels
```

The final SpatialExperiment object contains the adaptively smoothed gene 
expression data as an additional assay, as well initial clusters, entropy 
values, and clustSIGNAL clusters.

```{r embryo_final_spe}
# for convenience with downstream analyses, we can replace the original spe
# object with the one generated by ClustSIGNAL. This does not lead to any loss 
# of information as ClustSIGNAL only adds information to the specific object.
spe <- res_emb$spe_final
spe 
```

# Analysing clustSIGNAL results

In this section, we analyse the results from clustSIGNAL through spatial plots 
and clustering metrics.

## Visualising clustSIGNAL clusters

We use spatial coordinates of cells and their cluster labels and entropy values 
to visualize the clustering output.
```{r colors}
colors <- c("#635547", "#8EC792", "#9e6762", "#FACB12", "#3F84AA", "#0F4A9C", 
            "#ff891c", "#EF5A9D", "#C594BF", "#DFCDE4", "#139992", "#65A83E", 
            "#8DB5CE", "#005579", "#C9EBFB", "#B51D8D", "#532C8A", "#8870ad", 
            "#cc7818", "#FBBE92", "#EF4E22", "#f9decf", "#c9a997", "#C72228", 
            "#f79083", "#F397C0", "#DABE99", "#c19f70", "#354E23", "#C3C388",
            "#647a4f", "#CDE088", "#f7f79e", "#F6BFCB", "#7F6874", "#989898", 
            "#1A1A1A", "#FFFFFF", "#e6e6e6", "#77441B", "#F90026", "#A10037", 
            "#DA5921", "#E1C239", "#9DD84A")
```

```{r embryo_spatialPlots}
# for plotting with scater R package, we need to add the spatial coordinates 
# to the reduced dimension section
reducedDim(spe, "spatial") <- spatialCoords(spe)

# spatial plot
spt_clust <- scater::plotReducedDim(spe, colour_by = "clustSIGNAL",
                                    # specify spatial low dimension
                                    dimred = "spatial", point_alpha = 1,
                                    point_size = 4, scattermore = TRUE) +
  ggtitle("A") +
  scale_color_manual(values = colors) +
  guides(colour = guide_legend(title = "Clusters",
                               override.aes = list(size = 5))) +
  theme(text = element_text(size = 12))

# we can also display the entropy distribution at cluster-level to see which 
# clusters have cells from homogeneous/heterogeneous space. For this, we
# reorder the clusters by their median entropy value 
df_met <- spe |> colData() %>% as.data.frame()

ct_ent <- df_met %>%
  group_by(as.character(clustSIGNAL)) %>%
  summarise(mdEntropy = median(entropy))
cellOrder <- ct_ent$mdEntropy
names(cellOrder) <- ct_ent$`as.character(clustSIGNAL)`
cellOrder <- sort(cellOrder)

df_met$clustSIGNAL <- factor(df_met$clustSIGNAL, levels = names(cellOrder))
col_ent <- colors[as.numeric(names(cellOrder))]
box_clust <- df_met %>%
  ggplot(aes(x = clustSIGNAL, y = entropy, fill = clustSIGNAL)) +
  geom_boxplot() +
  scale_fill_manual(values = col_ent) +
  ggtitle("B") +
  labs(x = "clustSIGNAL clusters", y = "Entropy", name = "Clusters") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(size = 12),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

spt_clust + box_clust + patchwork::plot_layout(guides = "collect", 
                                               widths = c(2, 3))
```

The spatial location (A) and entropy distribution (B) of the clusters provide 
spatial context of the cells and their neighbourhoods, as well as the 
compositions of the neighbourhoods. For example, the low entropy of cluster 4 
indicates that the cells in this cluster are generally found in more 
homogeneous space, whereas the high entropy of cluster 7 cells indicates that 
they belong to regions with more cell diversity. This can also be visualized in 
the spatial plot.

## Cluster metrics

We assess the clustering efficiency of clustSIGNAL using the commonly used 
clustering metrics ARI, NMI, and silhouette width. ARI and NMI are usable only 
when prior cell annotation information is available, and assume that this cell 
annotation is ground truth. Here, ARI and NMI measure the similarity or 
agreement (respectively) between cluster labels obtained from clustSIGNAL and 
manual cell annotation labels. On the contrary, silhouette width is 
reference-free and evaluates how well a cell fits within its assigned cluster 
compared to other clusters.

```{r embryo_clusterMetrics}
# to assess the accuracy of clustering, the cluster labels are often compared to
# prior annotations. Here we compare ClustSIGNAL cluster labels to annotations 
# available with this public data
spe |> colData() %>% 
  as.data.frame() %>%
  summarise(
    ARI = aricode::ARI(celltype_mapped_refined, clustSIGNAL), # calculate ARI
    NMI = aricode::NMI(celltype_mapped_refined, clustSIGNAL)) # calculate NMI
```

## Entropy spread and distribution

The entropy values generated through clustSIGNAL process can be useful in 
analyzing the sample structure. The entropy range can indicate whether the 
tissue sample contains any homogeneous domain-like structures. For example, 
here the minimum entropy value is 0, which means some cells are placed in 
completely homogeneous space when looking at neighbourhood size of 30 cells 
(NN = 30 was used for generating this entropy data). Moreover, the mean entropy 
value is low, which can be interpreted as the tissue having at least some 
domain-like structures.

```{r embryo_entropyMetrics}
# we can assess the overall entropy distribution of the dataset
spe |> colData() %>% 
  as.data.frame() %>%
  summarise(min_Entropy = min(entropy),
            max_Entropy = max(entropy),
            mean_Entropy = mean(entropy))
```

```{r entropyPlots}
# we can also visualise the distribution and spread of the entropy values in 
# the sample(s)
hst_ent <- spe |> colData() %>% 
  as.data.frame() %>%
  ggplot(aes(entropy)) +
  geom_histogram(binwidth = 0.05) +
  ggtitle("A") +
  labs(x = "Entropy", y = "Number of regions") +
  theme_classic() +
  theme(text = element_text(size = 12))

spt_ent <- scater::plotReducedDim(spe, colour_by = "entropy",
                                    # specify spatial low dimension
                                    dimred = "spatial", point_alpha = 1,
                                    point_size = 4, scattermore = TRUE) +
  ggtitle("B") +
  scale_colour_gradient2("Entropy", low = "grey", high = "blue") +
  scale_size_continuous(range = c(0, max(spe$entropy))) +
  theme(text = element_text(size = 12))

hst_ent + spt_ent
```

The spread (A) and spatial distribution (B) of region entropy measures can be 
very useful in assessing the tissue composition of samples - low entropy 
regions are more homogeneous with domain-like structure, whereas high entropy 
regions are heterogeneous with more uniform distribution of cells.

# Generating entropy data only

To evaluate tissue structure using entropy values, we can run ClustSIGNAL 
step-by-step up to the entropy measurement component, without having to run the 
complete method. The entropy values will be added to the SpatialExperiment 
object and can be used for assessing tissue structure in terms of its 
"domainness".

```{r clustSIGNAL_onlyEntropy}
data(mEmbryo2) # this will load the logcounts and metadata to the environment

# as before, we read the data into a SpatialExperiment object
spe <- SpatialExperiment(assays = list(logcounts = me_expr),
                         colData = me_data, spatialCoordsNames = c("X", "Y"))

set.seed(100) # for reproducibility
# first generate low dimension data for initial clustering
spe <- scater::runPCA(spe) 
# perform first step in the ClustSIGNAL algorithm
# we only need to provide the spe object and low embedding information, other
# parameters can run on default values
spe <- clustSIGNAL::p1_clustering(spe, dimRed = "PCA")
# perform the next step of detecting the neighbourhood of all cells. By default,
# ClustSIGNAL identifies 30 nearest neighbours. We only need the spe object and 
# sample and cell labels for this - other parameters have default values
outReg <- clustSIGNAL::neighbourDetect(spe, samples = "sample_id", 
                                       cells = "uniqueID")
# finally perform the entropy calculation for each neighbourhood. This step can
# run in parallel - by default only 1 core is used
spe <- clustSIGNAL::entropyMeasure(spe, cells = "uniqueID", outReg$regXclust)
spe$entropy |> head() # entropy values are added to the spe object
```

# Multisample analysis with clustSIGNAL

Here, we use the MERFISH mouse hypothalamic preoptic region dataset from 
[Moffitt et al, 2018](https://www.science.org/doi/10.1126/science.aau5324), 
which contains spatial transcriptomics data from 181 samples, with 155 genes 
and a total of 1,027,080 cells. For this vignette, we subset the data by 
selecting a total of 6000 random cells from only 3 samples - Animal 1 Bregma 
-0.09 (2080 cells), Animal 7 Bregma 0.16 (1936 cells), and Animal 7 Bregma 
-0.09 (1984 cells), excluding cells that were manually annotated as 'ambiguous' 
and 20 genes that were assessed using a different technology.

We start the analysis by creating a SpatialExperiment object from the gene 
expression and cell information in the data subset, ensuring that the spatial 
coordinates are stored in spatialCoords within the SpatialExperiment object.

```{r hypothal_data_prep}
# this will load mh_expr and mh_data objects, containing gene expression 
# logcounts and cell metadata, respectively, to your environment
data(mHypothal)

# creates spe object using gene expression, cell metadata, and cell locations
spe2 <- SpatialExperiment(assays = list(logcounts = mh_expr), colData = mh_data,
                          # spatialCoordsNames requires column names in 
                          # mh_data that contain xy-coordinates of cells
                          spatialCoordsNames = c("X", "Y"))
spe2
```

Here, the cell labels are in the column 'Cell_ID' and sample labels are in 
'samples' column in the SpatialExperiment object.

```{r hypothal_data_columns}
spe2 |> colData() |> colnames() # to list the column names in the metadata
```

## clustSIGNAL run

One of the important concepts to take into account when running multisample 
analysis is batch effects. When gathering samples from different sources or 
through different technologies/procedures, some technical batch effects might 
be introduced into the dataset. We run clustSIGNAL in batch correction mode 
simply by setting batch = TRUE. The method then uses [harmony](https://portals.broadinstitute.org/harmony/) 
internally for batch correction.

```{r clustSIGNAL_multiRun }
set.seed(110) # for reproducibility
samples <- "samples" # column name containing sample names
cells <- "Cell_ID" # column name containing cell IDs
# ClustSIGNAL can be run on a dataset with multiple samples. As before, we need
# the SpatialExperiemnt object and column names of sample and cell labels. The 
# method can be run in parallel through the threads option. Here we use 
# thread = 4 to use 4 cores.
res_hyp <- clustSIGNAL(spe2, samples, cells, threads = 4, outputs = "a")
```

```{r hypothal_final_spe}
# for convenience with downstream analyses, we eplace the original spe object 
# with the one generated by ClustSIGNAL
spe2 <- res_hyp$spe_final
spe2
```

## Clustering metrics

Clustering and entropy results can be calculated and visualized for each sample. 
clustSIGNAL works well with samples that have more uniform distribution of 
cells.

```{r hypothal_samples}
samplesList <- spe2[[samples]] |> unique() # get unique sample names
samplesList
```

```{r hypothal_clusterMetrics}
# Here we compare ClustSIGNAL cluster labels to annotations available with this 
# public data to assess its accuracy. We also assess the overall entropy 
# distribution of the samples in the dataset
spe2 |> colData() %>% 
  as.data.frame() %>%
  group_by(samples) %>%
  # group cells by samples and for cells in each sample 
  # calculate the following metrics
  summarise(ARI = aricode::ARI(Cell_class, clustSIGNAL),
            NMI = aricode::NMI(Cell_class, clustSIGNAL),
            min_Entropy = min(entropy),
            max_Entropy = max(entropy),
            mean_Entropy = mean(entropy))
```

## Visualizing clustSIGNAL clusters

ClustSIGNAL performs clustering on all cells in the dataset in one run, thereby 
generating the same clusters across multiple samples. The user does not need to 
map cluster labels between samples. For example, cluster 1 represents the same 
cell type in all three samples, without needing explicit mapping between 
samples.

```{r hypothal_spatialPlots}
# for plotting with scater R package, we need to add the spatial coordinates 
# to the reduced dimension section
reducedDim(spe2, "spatial") <- spatialCoords(spe2)

# spatial plot
spt_clust2 <- scater::plotReducedDim(spe2, colour_by = "clustSIGNAL",
                                    # specify spatial low dimension
                                    dimred = "spatial", point_alpha = 1,
                                    point_size = 4, scattermore = TRUE) +
  scale_color_manual(values = colors) +
  facet_wrap(vars(spe2[[samples]]), scales = "free", nrow = 1) +
  guides(colour = guide_legend(title = "Clusters",
                               override.aes = list(size = 3))) +
  theme(text = element_text(size = 12))

# For cluster-level entropy distribution, we reorder the clusters by their 
# median entropy value in each sample
df_met2 <- spe2 |> colData() %>% as.data.frame()

box_clust2 <- list()
for (s in samplesList) {
  df_met_sub <- df_met2[df_met2[[samples]] == s, ]
  # calculating median entropy of each cluster in a sample
  ct_ent2 <- df_met_sub %>%
    group_by(as.character(clustSIGNAL)) %>%
    summarise(mdEntropy = median(entropy))
  # reordering clusters by their median entropy
  # low to high median entropy
  cellOrder2 <- ct_ent2$mdEntropy
  names(cellOrder2) <- ct_ent2$`as.character(clustSIGNAL)`
  cellOrder2 <- sort(cellOrder2)
  df_met_sub$clustSIGNAL <- factor(df_met_sub$clustSIGNAL, 
                                   levels = names(cellOrder2))

  # box plot of cluster entropy
  col_ent2 <- colors[as.numeric(names(cellOrder2))]
  box_clust2[[s]] <- df_met_sub %>%
    ggplot(aes(x = clustSIGNAL, y = entropy, fill = clustSIGNAL)) +
    geom_boxplot() +
    scale_fill_manual(values = col_ent2) +
    facet_wrap(vars(samples), nrow = 1) +
    labs(x = "clustSIGNAL clusters", y = "Entropy") +
    ylim(0, NA) +
    theme_classic() +
    theme(strip.text = element_blank(),
          legend.position = "none",
          text = element_text(size = 12),
          axis.text.x = element_text(angle = 90, vjust = 0.5))
}

spt_clust2 / (patchwork::wrap_plots(box_clust2[1:3], nrow = 1) +
               plot_layout(axes = "collect")) +
  plot_layout(guides = "collect", heights = c(5, 3)) +
  plot_annotation(
    title = "Spatial (top) and entropy (bottom) distributions of clusters")
```

The spatial location (top) and entropy distribution (bottom) of the clusters 
can be compared in a multisample analysis, providing spatial context of the 
cluster cells and their neighbourhood compositions in the different samples.

## Visualising entropy spread and distribution

In multisample analysis, the spread (A) and spatial distribution (B) of region 
entropy measures can be useful in assessing and comparing the tissue structure 
in the samples.

```{r hypothal_entropyPlots}
# we can assess the overall entropy distribution of each sample in the dataset
hst_ent2 <- spe2 |> colData() %>% 
  as.data.frame() %>%
  ggplot(aes(entropy)) +
  geom_histogram(binwidth = 0.05) +
  facet_wrap(vars(samples), nrow = 1) +
  labs(x = "Entropy", y = "Number of regions") +
  theme_classic() +
  theme(text = element_text(size = 12))

spt_ent2 <- scater::plotReducedDim(spe2, colour_by = "entropy",
                                  # specify spatial low dimension
                                  dimred = "spatial", point_alpha = 1,
                                  point_size = 4, scattermore = TRUE) +
  scale_colour_gradient2("Entropy", low = "grey", high = "blue") +
  scale_size_continuous(range = c(0, max(spe$entropy))) +
  facet_wrap(vars(spe2[[samples]]), scales = "free", nrow = 1) +
  theme(strip.text = element_blank(),
        text = element_text(size = 12))

hst_ent2 / spt_ent2 + plot_layout(heights = c(3,5)) +
    plot_annotation(
      title = "Entropy spread (top) and spatial distribution (bottom)")
```

<details>

<summary>**Session Information**</summary>

```{r}
sessionInfo()
```

</details>
