[{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"seqfish-mouse-embryo-data-analysis","dir":"Articles","previous_headings":"","what":"SeqFISH mouse embryo data analysis","title":"Single sample analysis","text":"run clustSIGNAL, need column names sample cell labels colData dataframe spatial experiment object. , cell labels column ‘uniqueID’ sample labels ‘embryo’ column.","code":"# load required packages library(clustSIGNAL) library(distances) library(cluster) library(aricode) library(dplyr) library(ggplot2) library(patchwork) data(mouseEmbryo2) spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(1): logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(4): uniqueID embryo celltype_mapped_refined sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(1): sample_id names(colData(spe)) #> [1] \"uniqueID\"                \"embryo\"                  #> [3] \"celltype_mapped_refined\" \"sample_id\""},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"running-clustsignal","dir":"Articles","previous_headings":"","what":"Running clustSIGNAL","title":"Single sample analysis","text":"output variable list can contain dataframe cluster names, matrix NN neighbours cell, final spe object, combination , depending choice ‘outputs’ selected.","code":"set.seed(100) samples = \"embryo\" cells = \"uniqueID\" res_emb = clustSIGNAL(spe, samples, cells, outputs = \"a\") #> [1] \"Calculating PCA to use as reduced dimension input.\" #> [1] \"clustSIGNAL run started. 2024-07-29 03:55:38.367586\" #> [1] \"Initial nonspatial clustering performed. Clusters = 16 2024-07-29 03:55:45.476204\" #> [1] \"Nonspatial subclustering performed. Subclusters = 84 2024-07-29 03:55:50.343114\" #> [1] \"Regions defined. 2024-07-29 03:55:56.432922\" #> [1] \"Region domainness calculated. 2024-07-29 03:56:08.366664\" #> [1] \"Smoothing performed. NN = 30 Kernel = G Spread = 0.05 2024-07-29 03:58:51.250896\" #> [1] \"Nonspatial clustering performed on smoothed data. Clusters = 25 2024-07-29 03:58:57.415019\" #> [1] \"clustSIGNAL run completed. 2024-07-29 03:58:57.417033\" names(res_emb) #> [1] \"clusters\"   \"neighbours\" \"spe_final\" head(res_emb$clusters, n = 3) #>                      Cells Clusters #> 1  embryo2_Pos29_cell10_z2       23 #> 2  embryo2_Pos29_cell10_z5       23 #> 3 embryo2_Pos29_cell100_z2       23 spe = res_emb$spe_final spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(2): logcounts smoothed #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(8): uniqueID embryo ... entropy reCluster #> reducedDimNames(2): PCA PCA.smooth #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(1): sample_id"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"calculating-clustering-metrics","dir":"Articles","previous_headings":"","what":"Calculating clustering metrics","title":"Single sample analysis","text":"","code":"# calculating silhouette width clusts <- as.numeric(as.character(spe$reCluster)) cXg_mat <- t(as.matrix(logcounts(spe))) distMat <- distances(cXg_mat) silCluster <- as.matrix(silhouette(clusts, distMat)) spe$rcSil <- silCluster[, 3]  # for datasets with annotated cell type information, we can also calculate  # metrics like adjusted rand index (ARI) and normalised mutual information (NMI) as.data.frame(colData(spe)) %>%   summarise(ARI = aricode::ARI(celltype_mapped_refined, reCluster),             NMI = aricode::NMI(celltype_mapped_refined, reCluster),             ASW = mean(rcSil),             min_Entropy = min(entropy),             max_Entropy = max(entropy),             mean_Entropy = mean(entropy)) #>         ARI       NMI       ASW min_Entropy max_Entropy mean_Entropy #> 1 0.2790963 0.5431904 0.0260925           0    3.254097     1.324275"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"visualising-clustsignal-outputs","dir":"Articles","previous_headings":"","what":"Visualising clustSIGNAL outputs","title":"Single sample analysis","text":"","code":"colors = c(\"#635547\", \"#8EC792\", \"#9e6762\", \"#FACB12\", \"#3F84AA\", \"#0F4A9C\",             \"#ff891c\", \"#EF5A9D\", \"#C594BF\", \"#DFCDE4\", \"#139992\", \"#65A83E\",             \"#8DB5CE\", \"#005579\", \"#C9EBFB\", \"#B51D8D\", \"#532C8A\", \"#8870ad\",             \"#cc7818\", \"#FBBE92\", \"#EF4E22\", \"#f9decf\", \"#c9a997\", \"#C72228\",             \"#f79083\", \"#F397C0\", \"#DABE99\", \"#c19f70\", \"#354E23\", \"#C3C388\",            \"#647a4f\", \"#CDE088\", \"#f7f79e\", \"#F6BFCB\", \"#7F6874\", \"#989898\",             \"#1A1A1A\", \"#FFFFFF\", \"#e6e6e6\", \"#77441B\", \"#F90026\", \"#A10037\",             \"#DA5921\", \"#E1C239\", \"#9DD84A\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"entropy-spread-and-distribution","dir":"Articles","previous_headings":"Visualising clustSIGNAL outputs","what":"Entropy spread and distribution","title":"Single sample analysis","text":"spread () spatial distribution (B) region entropy measures can useful assessing tissue composition samples - low entropy regions homogeneous domain-like structure, whereas high entropy regions heterogeneous uniform distribution cells.","code":"# Histogram of entropy spread hst_ent <- as.data.frame(colData(spe)) %>%   ggplot(aes(entropy)) +   geom_histogram(binwidth = 0.05) +   ggtitle(\"A\") +   labs(x = \"Entropy\", y = \"Number of regions\") +   theme_grey() +   theme(text = element_text(size = 12))  # Spatial plot showing sample entropy distribution spt_ent <- as.data.frame(colData(spe)) %>%   ggplot(aes(x = spatialCoords(spe)[, 1],               y = -spatialCoords(spe)[, 2])) +   geom_point(size = 0.5,               aes(colour = entropy)) +   scale_colour_gradient2(\"Entropy\", low = \"grey\", high = \"blue\") +   scale_size_continuous(range = c(0, max(spe$entropy))) +   ggtitle(\"B\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   theme_classic() +   theme(text = element_text(size = 12))  hst_ent + spt_ent"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/1_seqFISH_mouseEmbryo.html","id":"clustsignal-clusters-visualisation","dir":"Articles","previous_headings":"Visualising clustSIGNAL outputs","what":"clustSIGNAL clusters visualisation","title":"Single sample analysis","text":"spatial location () entropy distribution (B) clusters provide spatial context cluster cells neighbourhoods, well compositions neighbouhoods.","code":"df_ent = as.data.frame(colData(spe))  # spatial plot spt_clust <- df_ent %>%   ggplot(aes(x = spatialCoords(spe)[, 1],               y = -spatialCoords(spe)[, 2])) +   geom_point(size = 0.5, aes(colour = reCluster)) +   scale_color_manual(values = colors) +   ggtitle(\"A\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   guides(color = guide_legend(title = \"Clusters\",                                override.aes = list(size = 3))) +   theme_classic() +   theme(text = element_text(size = 12))  # calculating median entropy of each cluster celltype_ent = df_ent %>%   group_by(as.character(reCluster)) %>%   summarise(meanEntropy = median(entropy)) # reordering clusters by their median entropy # low to high median entropy cellOrder = celltype_ent$meanEntropy names(cellOrder) = celltype_ent$`as.character(reCluster)` cellOrder = sort(cellOrder) df_ent$reCluster = factor(df_ent$reCluster, levels = names(cellOrder)) # box plot of cluster entropy colors_ent = colors[as.numeric(names(cellOrder))] box_clust <- df_ent %>%   ggplot(aes(x = reCluster, y = entropy, fill = reCluster)) +   geom_boxplot() +   scale_fill_manual(values = colors_ent) +   ggtitle(\"B\") +   labs(x = \"clustSIGNAL clusters\", y = \"Entropy\") +   theme_classic() +   theme(legend.position = \"none\",         text = element_text(size = 12),         axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))  spt_clust + box_clust + patchwork::plot_layout(guides = \"collect\", widths = c(1, 2)) sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] parallel  stats4    stats     graphics  grDevices utils     datasets  #> [8] methods   base      #>  #> other attached packages: #>  [1] patchwork_1.2.0             ggplot2_3.5.1               #>  [3] dplyr_1.1.4                 aricode_1.0.3               #>  [5] cluster_2.1.6               distances_0.1.10            #>  [7] clustSIGNAL_0.1.0           doParallel_1.0.17           #>  [9] iterators_1.0.14            foreach_1.5.2               #> [11] SpatialExperiment_1.14.0    SingleCellExperiment_1.26.0 #> [13] SummarizedExperiment_1.34.0 Biobase_2.64.0              #> [15] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #> [17] IRanges_2.38.1              S4Vectors_0.42.1            #> [19] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [21] matrixStats_1.3.0           BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>  [1] gridExtra_2.3             rlang_1.1.4               #>  [3] magrittr_2.0.3            scater_1.32.1             #>  [5] compiler_4.4.1            DelayedMatrixStats_1.26.0 #>  [7] systemfonts_1.1.0         vctrs_0.6.5               #>  [9] pkgconfig_2.0.3           crayon_1.5.3              #> [11] fastmap_1.2.0             magick_2.8.4              #> [13] XVector_0.44.0            labeling_0.4.3            #> [15] scuttle_1.14.0            utf8_1.2.4                #> [17] rmarkdown_2.27            UCSC.utils_1.0.0          #> [19] ggbeeswarm_0.7.2          ragg_1.3.2                #> [21] xfun_0.46                 bluster_1.14.0            #> [23] zlibbioc_1.50.0           cachem_1.1.0              #> [25] beachmat_2.20.0           jsonlite_1.8.8            #> [27] highr_0.11                DelayedArray_0.30.1       #> [29] BiocParallel_1.38.0       irlba_2.3.5.1             #> [31] R6_2.5.1                  bslib_0.7.0               #> [33] jquerylib_0.1.4           Rcpp_1.0.13               #> [35] bookdown_0.40             knitr_1.48                #> [37] igraph_2.0.3              Matrix_1.7-0              #> [39] tidyselect_1.2.1          abind_1.4-5               #> [41] yaml_2.3.10               viridis_0.6.5             #> [43] codetools_0.2-20          lattice_0.22-6            #> [45] tibble_3.2.1              withr_3.0.0               #> [47] evaluate_0.24.0           desc_1.4.3                #> [49] pillar_1.9.0              BiocManager_1.30.23       #> [51] generics_0.1.3            sparseMatrixStats_1.16.0  #> [53] munsell_0.5.1             scales_1.3.0              #> [55] glue_1.7.0                tools_4.4.1               #> [57] BiocNeighbors_1.22.0      ScaledMatrix_1.12.0       #> [59] fs_1.6.4                  grid_4.4.1                #> [61] colorspace_2.1-1          GenomeInfoDbData_1.2.12   #> [63] beeswarm_0.4.0            BiocSingular_1.20.0       #> [65] vipor_0.4.7               cli_3.6.3                 #> [67] rsvd_1.0.5                textshaping_0.4.0         #> [69] fansi_1.0.6               S4Arrays_1.4.1            #> [71] viridisLite_0.4.2         gtable_0.3.5              #> [73] sass_0.4.9                digest_0.6.36             #> [75] SparseArray_1.4.8         ggrepel_0.9.5             #> [77] farver_2.1.2              rjson_0.2.21              #> [79] htmltools_0.5.8.1         pkgdown_2.1.0             #> [81] lifecycle_1.0.4           httr_1.4.7"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"merfish-mouse-preoptic-hypothalamus-data-analysis","dir":"Articles","previous_headings":"","what":"MERFISH mouse preoptic hypothalamus data analysis","title":"Multisample analysis","text":"run clustSIGNAL, need column names sample cell IDs colData dataframe spatial experiment object. , cell IDs column ‘Cell_ID’ sample IDs ‘samples’ column.","code":"# load required packages library(clustSIGNAL) library(distances) library(cluster) library(aricode) library(dplyr) library(ggplot2) library(patchwork) data(mousePH_subset) spe2 #> class: SpatialExperiment  #> dim: 135 17918  #> metadata(0): #> assays(1): logcounts #> rownames(135): Ace2 Adora2a ... Ttn Ttyh2 #> rowData names(0): #> colnames(17918): 8c7df84c-8a53-4aa4-86fd-26e575de9b0e #>   3617ee7c-c0a8-4f18-b9bd-c7ca737ff665 ... #>   96bc85ce-b993-4fb1-8e0c-165f83f0cfd0 #>   a5847bc4-94d4-44c0-8974-87388b951b0c #> colData names(4): Cell_ID Cell_class sample_id samples #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : Centroid_X Centroid_Y #> imgData names(1): sample_id names(colData(spe2)) #> [1] \"Cell_ID\"    \"Cell_class\" \"sample_id\"  \"samples\""},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"running-clustsignal","dir":"Articles","previous_headings":"","what":"Running clustSIGNAL","title":"Multisample analysis","text":"","code":"set.seed(101) samples = \"samples\" cells = \"Cell_ID\" res_hyp = clustSIGNAL(spe2, samples, cells, outputs = \"a\") #> [1] \"Calculating PCA to use as reduced dimension input.\" #> [1] \"clustSIGNAL run started. 2024-07-29 03:59:57.729561\" #> [1] \"Initial nonspatial clustering performed. Clusters = 14 2024-07-29 04:00:07.790971\" #> [1] \"Nonspatial subclustering performed. Subclusters = 96 2024-07-29 04:00:12.852782\" #> [1] \"Regions defined. 2024-07-29 04:00:20.674816\" #> [1] \"Region domainness calculated. 2024-07-29 04:00:34.643742\" #> [1] \"Smoothing performed. NN = 30 Kernel = G Spread = 0.05 2024-07-29 04:02:11.349579\" #> [1] \"Nonspatial clustering performed on smoothed data. Clusters = 15 2024-07-29 04:02:22.229718\" #> [1] \"clustSIGNAL run completed. 2024-07-29 04:02:22.231778\" spe2 = res_hyp$spe_final spe2 #> class: SpatialExperiment  #> dim: 135 17918  #> metadata(0): #> assays(2): logcounts smoothed #> rownames(135): Ace2 Adora2a ... Ttn Ttyh2 #> rowData names(0): #> colnames(17918): 8c7df84c-8a53-4aa4-86fd-26e575de9b0e #>   3617ee7c-c0a8-4f18-b9bd-c7ca737ff665 ... #>   96bc85ce-b993-4fb1-8e0c-165f83f0cfd0 #>   a5847bc4-94d4-44c0-8974-87388b951b0c #> colData names(8): Cell_ID Cell_class ... entropy reCluster #> reducedDimNames(2): PCA PCA.smooth #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : Centroid_X Centroid_Y #> imgData names(1): sample_id"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"calculating-clustering-metrics","dir":"Articles","previous_headings":"","what":"Calculating clustering metrics","title":"Multisample analysis","text":"","code":"samplesList <- levels(spe2[[samples]]) # calculating silhouette width per sample silWidthRC <- matrix(nrow = 0, ncol = 3) for (s in samplesList) {   speX <- spe2[, spe2[[samples]] == s]   clust_sub <- as.numeric(as.character(speX$reCluster))   cXg <- t(as.matrix(logcounts(speX)))   distMat <- distances(cXg)   silCluster <- as.matrix(silhouette(clust_sub, distMat))   silWidthRC <- rbind(silWidthRC, silCluster) } spe2$rcSil <- silWidthRC[, 3] # for datasets with annotated cell type information, we can also calculate  # metrics like adjusted rand index (ARI) and normalised mutual information (NMI) as.data.frame(colData(spe2)) %>%   group_by(samples) %>%   summarise(ARI = aricode::ARI(Cell_class, reCluster),             NMI = aricode::NMI(Cell_class, reCluster),             ASW = mean(rcSil),             min_Entropy = min(entropy),             max_Entropy = max(entropy),             mean_Entropy = mean(entropy)) #> # A tibble: 3 × 7 #>   samples   ARI   NMI    ASW min_Entropy max_Entropy mean_Entropy #>   <fct>   <dbl> <dbl>  <dbl>       <dbl>       <dbl>        <dbl> #> 1 1.-0.09 0.391 0.534 0.0681       0.561        4.57         3.55 #> 2 7.-0.09 0.390 0.544 0.105        0.211        4.71         3.54 #> 3 7.0.16  0.446 0.575 0.0860       1.04         4.57         3.45"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"visualising-clustsignal-outputs","dir":"Articles","previous_headings":"","what":"Visualising clustSIGNAL outputs","title":"Multisample analysis","text":"","code":"colors = c(\"#635547\", \"#8EC792\", \"#9e6762\", \"#FACB12\", \"#3F84AA\", \"#0F4A9C\",             \"#ff891c\", \"#EF5A9D\", \"#C594BF\", \"#DFCDE4\", \"#139992\", \"#65A83E\",             \"#8DB5CE\", \"#005579\", \"#C9EBFB\", \"#B51D8D\", \"#532C8A\", \"#8870ad\",             \"#cc7818\", \"#FBBE92\", \"#EF4E22\", \"#f9decf\", \"#c9a997\", \"#C72228\",             \"#f79083\", \"#F397C0\", \"#DABE99\", \"#c19f70\", \"#354E23\", \"#C3C388\",            \"#647a4f\", \"#CDE088\", \"#f7f79e\", \"#F6BFCB\", \"#7F6874\", \"#989898\",             \"#1A1A1A\", \"#FFFFFF\", \"#e6e6e6\", \"#77441B\", \"#F90026\", \"#A10037\",             \"#DA5921\", \"#E1C239\", \"#9DD84A\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"entropy-spread-and-distribution","dir":"Articles","previous_headings":"Visualising clustSIGNAL outputs","what":"Entropy spread and distribution","title":"Multisample analysis","text":"multisample analysis, spread () spatial distribution (B) region entropy measures can useful assessing comparing tissue structure samples.","code":"# Histogram of entropy spread hst_ent <- as.data.frame(colData(spe2)) %>%   ggplot(aes(entropy)) +   geom_histogram(binwidth = 0.05) +   ggtitle(\"A\") +   facet_wrap(vars(samples), nrow = 1) +   labs(x = \"Entropy\", y = \"Number of regions\") +   theme_grey() +   theme(text = element_text(size = 12))  # Spatial plot showing sample entropy distribution spt_ent <- as.data.frame(colData(spe2)) %>%   ggplot(aes(x = spatialCoords(spe2)[, 1],               y = -spatialCoords(spe2)[, 2])) +   geom_point(size = 0.5,               aes(colour = entropy)) +   scale_colour_gradient2(\"Entropy\", low = \"grey\", high = \"blue\") +   scale_size_continuous(range = c(0, max(spe2$entropy))) +   facet_wrap(vars(samples), scales = \"free\", nrow = 1) +   ggtitle(\"B\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   theme_classic() +   theme(text = element_text(size = 12),         axis.text.x = element_text(angle = 90, vjust = 0.5))  hst_ent / spt_ent"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/2_MERFISH_mouseHypothalamus.html","id":"clustsignal-clusters-visualisation","dir":"Articles","previous_headings":"Visualising clustSIGNAL outputs","what":"clustSIGNAL clusters visualisation","title":"Multisample analysis","text":"spatial location (top) entropy distribution (bottom) clusters can compared multisample analysis, providing spatial context cluster cells neighbourhood compositions different samples.","code":"df_ent = as.data.frame(colData(spe2))  # spatial plot spt_clust <- df_ent %>%   ggplot(aes(x = spatialCoords(spe2)[, 1],               y = -spatialCoords(spe2)[, 2])) +   geom_point(size = 0.5, aes(colour = reCluster)) +   scale_color_manual(values = colors) +   facet_wrap(vars(samples), scales = \"free\", nrow = 1) +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   guides(color = guide_legend(title = \"Clusters\",                                override.aes = list(size = 3))) +   theme_classic() +   theme(text = element_text(size = 12),         axis.text.x = element_text(angle = 90, vjust = 0.5))  box_clust = list() for (s in samplesList) {   df_ent_sub = as.data.frame(colData(spe2)[spe2[[samples]] == s, ])   # calculating median entropy of each cluster in a sample   celltype_ent = df_ent_sub %>%     group_by(as.character(reCluster)) %>%     summarise(meanEntropy = median(entropy))   # reordering clusters by their median entropy   # low to high median entropy   cellOrder = celltype_ent$meanEntropy   names(cellOrder) = celltype_ent$`as.character(reCluster)`   cellOrder = sort(cellOrder)   df_ent_sub$reCluster = factor(df_ent_sub$reCluster, levels = names(cellOrder))      # box plot of cluster entropy   colors_ent = colors[as.numeric(names(cellOrder))]   box_clust[[s]] <- df_ent_sub %>%     ggplot(aes(x = reCluster, y = entropy, fill = reCluster)) +     geom_boxplot() +     scale_fill_manual(values = colors_ent) +     facet_wrap(vars(samples), nrow = 1) +     labs(x = \"clustSIGNAL clusters\", y = \"Entropy\") +     ylim(0, NA) +     theme_classic() +     theme(legend.position = \"none\",           text = element_text(size = 12),           axis.text.x = element_text(angle = 90, vjust = 0.5)) }  spt_clust / (patchwork::wrap_plots(box_clust[1:3], nrow = 1) +                 plot_layout(axes = \"collect\")) +    plot_layout(guides = \"collect\") +   plot_annotation(title = \"Spatial and entropy distributions of clusters\") sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] parallel  stats4    stats     graphics  grDevices utils     datasets  #> [8] methods   base      #>  #> other attached packages: #>  [1] patchwork_1.2.0             ggplot2_3.5.1               #>  [3] dplyr_1.1.4                 aricode_1.0.3               #>  [5] cluster_2.1.6               distances_0.1.10            #>  [7] clustSIGNAL_0.1.0           doParallel_1.0.17           #>  [9] iterators_1.0.14            foreach_1.5.2               #> [11] SpatialExperiment_1.14.0    SingleCellExperiment_1.26.0 #> [13] SummarizedExperiment_1.34.0 Biobase_2.64.0              #> [15] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #> [17] IRanges_2.38.1              S4Vectors_0.42.1            #> [19] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [21] matrixStats_1.3.0           BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>  [1] gridExtra_2.3             rlang_1.1.4               #>  [3] magrittr_2.0.3            scater_1.32.1             #>  [5] compiler_4.4.1            DelayedMatrixStats_1.26.0 #>  [7] systemfonts_1.1.0         vctrs_0.6.5               #>  [9] pkgconfig_2.0.3           crayon_1.5.3              #> [11] fastmap_1.2.0             magick_2.8.4              #> [13] XVector_0.44.0            labeling_0.4.3            #> [15] scuttle_1.14.0            utf8_1.2.4                #> [17] rmarkdown_2.27            UCSC.utils_1.0.0          #> [19] ggbeeswarm_0.7.2          ragg_1.3.2                #> [21] xfun_0.46                 bluster_1.14.0            #> [23] zlibbioc_1.50.0           cachem_1.1.0              #> [25] beachmat_2.20.0           jsonlite_1.8.8            #> [27] highr_0.11                DelayedArray_0.30.1       #> [29] BiocParallel_1.38.0       irlba_2.3.5.1             #> [31] R6_2.5.1                  bslib_0.7.0               #> [33] jquerylib_0.1.4           Rcpp_1.0.13               #> [35] bookdown_0.40             knitr_1.48                #> [37] igraph_2.0.3              Matrix_1.7-0              #> [39] tidyselect_1.2.1          abind_1.4-5               #> [41] yaml_2.3.10               viridis_0.6.5             #> [43] codetools_0.2-20          lattice_0.22-6            #> [45] tibble_3.2.1              withr_3.0.0               #> [47] evaluate_0.24.0           desc_1.4.3                #> [49] pillar_1.9.0              BiocManager_1.30.23       #> [51] generics_0.1.3            sparseMatrixStats_1.16.0  #> [53] munsell_0.5.1             scales_1.3.0              #> [55] glue_1.7.0                tools_4.4.1               #> [57] BiocNeighbors_1.22.0      ScaledMatrix_1.12.0       #> [59] fs_1.6.4                  grid_4.4.1                #> [61] colorspace_2.1-1          GenomeInfoDbData_1.2.12   #> [63] beeswarm_0.4.0            BiocSingular_1.20.0       #> [65] vipor_0.4.7               cli_3.6.3                 #> [67] rsvd_1.0.5                textshaping_0.4.0         #> [69] fansi_1.0.6               S4Arrays_1.4.1            #> [71] viridisLite_0.4.2         gtable_0.3.5              #> [73] sass_0.4.9                digest_0.6.36             #> [75] SparseArray_1.4.8         ggrepel_0.9.5             #> [77] farver_2.1.2              rjson_0.2.21              #> [79] htmltools_0.5.8.1         pkgdown_2.1.0             #> [81] lifecycle_1.0.4           httr_1.4.7"},{"path":"https://sydneybiox.github.io/clustSIGNAL/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Pratibha Panwar. Maintainer.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"c), person), person), person), person) (2024). clustSIGNAL: clustSIGNAL: spatial clustering method. R package version 0.1.0, https://sydneybiox.github.io/clustSIGNAL/.","code":"@Manual{,   title = {clustSIGNAL: clustSIGNAL: a spatial clustering method},   author = {{c)} and {person)} and {person)} and {person)} and {person)}},   year = {2024},   note = {R package version 0.1.0},   url = {https://sydneybiox.github.io/clustSIGNAL/}, }"},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"clustsignal","dir":"","previous_headings":"","what":"clustSIGNAL: a spatial clustering method","title":"clustSIGNAL: a spatial clustering method","text":"clustSIGNAL: clustering Spatially Informed Gene expression Neighbourhood Adapted Learning. R package perform spatial clustering spatially-resolved transcriptomics datasets. , calculate entropy measure “domainness” cell neighbourhoods, use generate weight distributions perform adaptive smoothing gene expression. Homogeneous neighbourhoods low entropy, , smoothing performed cells neighbourhoods. Contrarily, heterogeneous neighbourhoods high entropy smoothed much smaller region. approach overcomes data sparsity gene expression also incorporates spatial context form cell arrangement information neighbourhood. resulting adaptively smoothed gene expression used downstream analyses like clustering. tutorials use clustSIGNAL, see vignettes website.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"clustSIGNAL: a spatial clustering method","text":"can install clustSIGNAL package GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"SydneyBioX/clustSIGNAL\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"method-description","dir":"","previous_headings":"","what":"Method description","title":"clustSIGNAL: a spatial clustering method","text":"Figure: clustSIGNAL method overview. , present clustSIGNAL, spatial clustering method developed handle data sparsity considering variability cell arrangement tissue regions. core steps involved method sequential: 1. method starts non-spatial clustering subclustering (default louvain clustering) classify cells subclusters refer ‘putative cell type’ groups. 2. neighbourhood cell defined terms ‘putative cell type’ group composition. 3. cells neighbourhood also sorted rearranged neighbours belonging ‘putative cell type’ group index cell placed closer . 4. Neighbourhood “domainness” measured entropy, high entropy values indicate heterogeneous neighbourhoods low entropy values indicate homogeneous neighbourhoods. 5. entropy values used generate weight distributions specific neighbourhood. 6. gene expressions cells adaptively smoothed using entropy-guided weight distributions; cells heterogeneous neighbourhoods (high entropy) undergo smoothing smaller region, whereas cells homogeneous neighbourhoods (low entropy) undergo smoothing larger region. 7. Non-spatial clustering performed adaptively smoothed gene expression generate clustSIGNAL clusters represent cell types.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"clustsignal-parameters","dir":"","previous_headings":"","what":"clustSIGNAL parameters","title":"clustSIGNAL: a spatial clustering method","text":"clustSIGNAL package uses SpatialExperiment object input. provide users number parameters explore experiment , well prior tested default values quick runs. clustSIGNAL can used single sample multisample analysis just one function call. list parameters offered possible values: spe - SpatialExperiment object cell spatial coordinates spatialCoords matrix. samples - column name cell metadata containing sample names. cells - column name cell metadata containing cell IDs. dimRed - dimensionality reduction method name low embedding data. Default “None”, case PCA calculated used low dimension data. NN - neighbourhood size terms number nearest neighbours consider. Value > 1. Default value 30. kernel - type weight distribution use. Can Gaussian (default) exponential distribution. spread - value distribution parameter - standard deviation Gaussian distribution rate exponential distribution. Default value 0.05, recommended Gaussian distribution. exponential distribution, recommended value 20. sort - whether cell neighbourhoods sorted ‘putative cell type’ grouping. Default value True. threads - number cpus use parallel runs. Default value 1. outputs - choice output types. Default value ‘c’ data frame cell IDs cluster numbers. possible values include - ‘n’ list data frame clusters matrix neighbourhood cell IDs, ‘s’ list data frame clusters final SpatialExperiment object, ‘’ list 3 outputs. … - additional options non-spatial clustering algorithms bluster package, e.g., KmeansParam options like centers iter.max, NNGraphParam options like k cluster.fun.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"running-clustsignal","dir":"","previous_headings":"","what":"Running clustSIGNAL","title":"clustSIGNAL: a spatial clustering method","text":"running clustSIGNAL, important ensure SpatialExperiment object input spatial coordinates stored spatialCoords matrix. Otherwise, method throw error asking user provide spatial coordinates.","code":"# load required packages library(clustSIGNAL)  data(mouseEmbryo2) spe  # Here, the cell labels are in the column 'uniqueID' and sample labels are in 'embryo' column.  set.seed(100) res = clustSIGNAL(spe, samples = \"embryo\", cells = \"uniqueID\", dimRed = \"PCA\", cluster.fun = \"leiden\", outputs = \"a\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive smoothing — adaptiveSmoothing","title":"Adaptive smoothing — adaptiveSmoothing","text":"function perform weighted, adaptive smoothing gene expression based heterogeneity cell neighbourhood. Heterogeneous neighbourhoods smoothed less higher weights given cells belonging initial group. Homogeneous neighbourhoods smoothed similar weights given cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive smoothing — adaptiveSmoothing","text":"","code":"adaptiveSmoothing(spe, nnCells, NN, kernel, spread)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive smoothing — adaptiveSmoothing","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups, entropy outputs included. nnCells character matrix NN nearest neighbours - rows cells columns nearest neighbours ranged closest farthest neighbour. sort = TRUE, neighbours belonging 'putative cell type' group cell moved closer . NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. kernel character type distribution used. two valid values \"G\" \"E\". G Gaussian distribution, E exponential distribution. Default value \"G\". spread numeric value distribution spread, represented standard deviation Gaussian distribution rate exponential distribution. Default value 0.05 Gaussian distribution 20 exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive smoothing — adaptiveSmoothing","text":"SpatialExperiment object including smoothed gene expression values another assay.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive smoothing — adaptiveSmoothing","text":"","code":"data(mouseEmbryo2)  # requires matrix containing NN nearest neighbour cell labels (nnCells), # generated using the neighbourDetect() function spe <- adaptiveSmoothing(spe, nnCells, NN = 30, kernel = \"G\", spread = 0.05) #> Error in seq.default(0, ed, length.out = NN): 'to' must be of length 1 spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(1): logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(4): uniqueID embryo celltype_mapped_refined sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(1): sample_id"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":null,"dir":"Reference","previous_headings":"","what":"clustSIGNAL — clustSIGNAL","title":"clustSIGNAL — clustSIGNAL","text":"clustering method cell type classification spatial transcriptomics data. tool generates uses adaptively smoothed, spatially informed gene expression data clustering.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"clustSIGNAL — clustSIGNAL","text":"","code":"clustSIGNAL(   spe,   samples,   cells,   dimRed = \"None\",   NN = 30,   kernel = \"G\",   spread = 0.05,   sort = TRUE,   threads = 1,   outputs = \"c\",   ... )"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"clustSIGNAL — clustSIGNAL","text":"spe SpatialExperiment object. samples character indicating name colData(spe) column containing sample names. cells character indicating name colData(spe) column containing cell IDs. dimRed character indicating name reduced dimensions use SpatialExperiment object (.e., reducedDimNames(spe)). Default value 'PCA'. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. kernel character type distribution used. two valid values \"G\" \"E\". G Gaussian distribution, E exponential distribution. Default value \"G\". spread numeric value distribution spread, represented standard deviation Gaussian distribution rate exponential distribution. Default value 0.05 Gaussian distribution 20 exponential distribution. sort logical parameter whether sort neighbourhood region description. Default value TRUE. threads numeric value number CPU cores used analysis. Default value set 4 cores. outputs character type output return user. \"c\" data frame cell IDs respective cluster numbers (default), \"n\" list dataframe clusters plus neighbourhood matrix, \"s\" list dataframe clusters plus final spatialExperiment object, \"\" list outputs. ... additional parameters TwoStepParam clustering methods. Include parameters like k number nearest neighbours cluster.fun selecting community detection method. Default values k = 5, cluster.fun = \"louvain\".","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"clustSIGNAL — clustSIGNAL","text":"list outputs 1. clusters: data frame cell names cluster classification. 2. neighbours: matrix cell names names NN nearest neighbour cells. 3. spe_final: SpatialExperiment object initial 'putative cell type' groups, entropy values, smoothed gene expression, post-smoothing clusters, silhouette widths included.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"clustSIGNAL — clustSIGNAL","text":"","code":"data(mouseEmbryo2)  names(colData(spe)) #> [1] \"uniqueID\"                \"embryo\"                  #> [3] \"celltype_mapped_refined\" \"sample_id\"               # identify the column names with cell and sample labels samples = \"embryo\" cells = \"uniqueID\" res_list <- clustSIGNAL(spe, samples, cells, dimRed = \"PCA\", outputs = \"c\") #> Error in clustSIGNAL(spe, samples, cells, dimRed = \"PCA\", outputs = \"c\"): The specified reduced dimension data does not exist."},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell neighbourhood composition — .calculateProp","title":"Cell neighbourhood composition — .calculateProp","text":"function calculate cell neighbourhood composition 'putative' cell types.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell neighbourhood composition — .calculateProp","text":"","code":".calculateProp(arr)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell neighbourhood composition — .calculateProp","text":"arr vector 'putative cell type' assignments cell neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell neighbourhood composition — .calculateProp","text":"table 'putative cell type' proportions neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell naming — .cellName","title":"Neighbour cell naming — .cellName","text":"function fetch cell IDs.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell naming — .cellName","text":"","code":".cellName(cell, Clust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell naming — .cellName","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. Clust data frame initial cluster assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell naming — .cellName","text":"data frame cell IDs neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell sorting — .cellNameSort","title":"Neighbour cell sorting — .cellNameSort","text":"function perform neighbourhood cell sorting. Neighbourhood cells belong 'putative cell type' central cell moved closer central cell.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell sorting — .cellNameSort","text":"","code":".cellNameSort(cell, Clust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell sorting — .cellNameSort","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. Clust data frame initial cluster assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell sorting — .cellNameSort","text":"data frame cell IDs sorted neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell 'putative cell type' assignment — .clustNum","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"function fetch 'putative cell type' assignments cell.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"","code":".clustNum(cell, subClust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. subClust data frame 'putative cell type' assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"data frame 'putative cell type' assignments neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential distribution weights — .exp_kernel","title":"Exponential distribution weights — .exp_kernel","text":"function generate weights exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential distribution weights — .exp_kernel","text":"","code":".exp_kernel(ed, NN, rate)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential distribution weights — .exp_kernel","text":"ed numeric value entropy neighbourhood. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. rate numeric value rate exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential distribution weights — .exp_kernel","text":"numeric vector weights.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian distribution weights — .gauss_kernel","title":"Gaussian distribution weights — .gauss_kernel","text":"function generate weights Gaussian distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian distribution weights — .gauss_kernel","text":"","code":".gauss_kernel(ed, NN, sd)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian distribution weights — .gauss_kernel","text":"ed numeric value entropy neighbourhood. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. sd numeric value standard deviation Gaussian distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian distribution weights — .gauss_kernel","text":"numeric vector weights.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":null,"dir":"Reference","previous_headings":"","what":"Smoothing per neighbourhood — .smoothedData","title":"Smoothing per neighbourhood — .smoothedData","text":"function perform weighted moving average gene expression neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smoothing per neighbourhood — .smoothedData","text":"","code":".smoothedData(mat, weight)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smoothing per neighbourhood — .smoothedData","text":"mat gene expression matrix genes rows neighbourhood cells columns. weight column matrix weights, number rows equal number neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smoothing per neighbourhood — .smoothedData","text":"column matrix smoothed gene expression.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":null,"dir":"Reference","previous_headings":"","what":"Domainness measure — entropyMeasure","title":"Domainness measure — entropyMeasure","text":"function measure heterogeneity cell's neighbourhood terms entropy, homogeneous neighbourhoods low entropy heterogeneous neighbourhoods high entropy.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Domainness measure — entropyMeasure","text":"","code":"entropyMeasure(spe, cells, regXclust, threads)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Domainness measure — entropyMeasure","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups included. cells character vector cell IDs cell. Length vector must equal number cells spatialExperiment object (.e. number rows colData(spe)). regXclust list vectors cell's neighbourhood composition indicated proportion 'putative cell type' groups contains. threads numeric value number CPU cores used analysis.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Domainness measure — entropyMeasure","text":"SpatialExperiment object including entropy values cell neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Domainness measure — entropyMeasure","text":"","code":"data(mouseEmbryo2)  # requires list of containing cluster proportions of each region (regXclust), # generated using the neighbourDetect() function spe <- entropyMeasure(spe, cells = \"uniqueID\", regXclust, threads = 1) #> Error in eval(expr, envir, enclos): object 'regXclust' not found head(spe$entropy) #> NULL"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell neighbourhood detection — neighbourDetect","title":"Cell neighbourhood detection — neighbourDetect","text":"function identify neighbourhood cell. sort = TRUE, neighbourhoods also sorted cells belonging group central cell arranged closer .","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell neighbourhood detection — neighbourDetect","text":"","code":"neighbourDetect(spe, samples, NN, cells, sort)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell neighbourhood detection — neighbourDetect","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups included. samples character vector sample names cells belong. Length vector must equal number cells spatialExperiment object (.e. number rows colData(spe)). NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. cells character vector cell IDs cell. Length vector must equal number cells SpatialExperiment object (.e. number rows colData(spe)). sort logical parameter whether sort neighbourhood region description. Default value TRUE.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell neighbourhood detection — neighbourDetect","text":"list containing two items: 1. nnCells, character matrix NN nearest neighbours - rows cells columns nearest neighbours ranged closest farthest neighbour. sort = TRUE, neighbours belonging 'putative cell type' group cell moved closer . 2. regXclust, list vectors cell's neighbourhood composition indicated proportion 'putative cell type' groups contains.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell neighbourhood detection — neighbourDetect","text":"","code":"data(mouseEmbryo2)  out_list <- neighbourDetect(spe, samples = \"embryo\", NN = 30, cells = \"uniqueID\", sort = TRUE) #> Error in `.rowNamesDF<-`(x, value = value): invalid 'row.names' length names(out_list) #> Error in eval(expr, envir, enclos): object 'out_list' not found"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-spatial clustering — nsClustering","title":"Non-spatial clustering — nsClustering","text":"function containing two steps used different times clustSIGNAL workflow. initial non-spatial clustering sub-clustering step (reclust = FALSE) used generate groups ‘putative cell types’, whereas later non-spatial clustering step (reclust = TRUE) used cluster adaptively smoothed gene expression data.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-spatial clustering — nsClustering","text":"","code":"nsClustering(spe, dimRed, reclust, ...)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-spatial clustering — nsClustering","text":"spe SpatialExperiment object. reclust = FALSE, object contain logcounts PCA, reculst = TRUE, object contain smoothed gene expression. reclust logical parameter handled within method.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-spatial clustering — nsClustering","text":"SpatialExperiment object containing 'putative cell type' group allotted cell (reclust = FALSE) clusters generated smoothed data (reclust = TRUE).","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-spatial clustering — nsClustering","text":"","code":"data(mouseEmbryo2)  # for non-spatial clustering of normalised counts spe <- nsClustering(spe, dimRed = \"PCA\", reclust = FALSE) #> Error in value[[3L]](cond): invalid subscript 'type' in 'reducedDim(<SpatialExperiment>, type=\"character\", ...)': #>   'PCA' not in 'reducedDimNames(<SpatialExperiment>)' head(spe$nsCluster) #> NULL head(spe$nsSubcluster) #> NULL  # for non-spatial clustering of adaptively smoothed counts spe <- nsClustering(spe, dimRed = \"PCA\", reclust = TRUE) #> Error in assay(x, assay.type): 'assay(<SpatialExperiment>, i=\"character\", ...)' invalid subscript 'i' #> 'smoothed' not in names(assays(<SpatialExperiment>)) head(spe$reCluster) #> NULL"}]
