[{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/MERFISH_mouseHypothalamus.html","id":"merfish-mouse-preoptic-hypothalamus-data-analysis","dir":"Articles","previous_headings":"","what":"MERFISH mouse preoptic hypothalamus data analysis","title":"Multisample analysis","text":"run clustSIGNAL, need column names sample cell IDs colData dataframe spatial experiment object. , cell IDs column ‘Cell_ID’ sample IDs ‘samples’ column.","code":"# load required packages library(clustSIGNAL) library(distances) library(cluster) library(aricode) library(dplyr) library(ggplot2) library(patchwork) data(mousePH_subset) spe2 #> class: SpatialExperiment  #> dim: 135 23982  #> metadata(0): #> assays(2): counts logcounts #> rownames(135): Ace2 Adora2a ... Ttn Ttyh2 #> rowData names(0): #> colnames(23982): 4ec0fe04-ca4d-4884-8bb5-352150a62df0 #>   13b8ca66-c045-4bce-9780-d5451d3157d2 ... #>   96bc85ce-b993-4fb1-8e0c-165f83f0cfd0 #>   a5847bc4-94d4-44c0-8974-87388b951b0c #> colData names(10): Cell_ID Animal_ID ... sizeFactor samples #> reducedDimNames(3): PCA UMAP spatial #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : Centroid_X Centroid_Y #> imgData names(1): sample_id names(colData(spe2)) #>  [1] \"Cell_ID\"           \"Animal_ID\"         \"Animal_sex\"        #>  [4] \"Behavior\"          \"Bregma\"            \"Cell_class\"        #>  [7] \"Neuron_cluster_ID\" \"sample_id\"         \"sizeFactor\"        #> [10] \"samples\""},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/MERFISH_mouseHypothalamus.html","id":"run-clustsignal","dir":"Articles","previous_headings":"","what":"Run clustSIGNAL","title":"Multisample analysis","text":"","code":"set.seed(101) samples = \"samples\" cells = \"Cell_ID\" dimRed = \"PCA\" res_hyp = clustSIGNAL(spe2, samples, cells, dimRed, outputs = \"a\") #> [1] \"clustSIGNAL run started. 2024-07-25 08:18:15.339039\" #> [1] \"Initial nonspatial clustering performed. Clusters = 16 2024-07-25 08:18:32.056171\" #> [1] \"Nonspatial subclustering performed. Subclusters = 109 2024-07-25 08:18:40.518821\" #> [1] \"Regions defined. 2024-07-25 08:18:51.116849\" #> [1] \"Region domainness calculated. 2024-07-25 08:19:07.365422\" #> [1] \"Smoothing performed. NN = 30 Kernel = G Spread = 0.05 2024-07-25 08:21:24.542101\" #> [1] \"Nonspatial clustering performed on smoothed data. Clusters = 17 2024-07-25 08:21:42.418329\" #> [1] \"clustSIGNAL run completed. 2024-07-25 08:21:42.421167\" spe2 = res_hyp$spe_final spe2 #> class: SpatialExperiment  #> dim: 135 23982  #> metadata(0): #> assays(3): counts logcounts smoothed #> rownames(135): Ace2 Adora2a ... Ttn Ttyh2 #> rowData names(0): #> colnames(23982): 4ec0fe04-ca4d-4884-8bb5-352150a62df0 #>   13b8ca66-c045-4bce-9780-d5451d3157d2 ... #>   96bc85ce-b993-4fb1-8e0c-165f83f0cfd0 #>   a5847bc4-94d4-44c0-8974-87388b951b0c #> colData names(14): Cell_ID Animal_ID ... entropy reCluster #> reducedDimNames(4): PCA UMAP spatial PCA.smooth #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : Centroid_X Centroid_Y #> imgData names(1): sample_id"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/MERFISH_mouseHypothalamus.html","id":"calculate-clustering-metrics","dir":"Articles","previous_headings":"","what":"Calculate clustering metrics","title":"Multisample analysis","text":"","code":"samplesList <- levels(spe2[[samples]]) # calculating silhouette width per sample silWidthRC <- matrix(nrow = 0, ncol = 3) for (s in samplesList) {   speX <- spe2[, spe2[[samples]] == s]   clust_sub <- as.numeric(as.character(speX$reCluster))   cXg <- t(as.matrix(logcounts(speX)))   distMat <- distances(cXg)   silCluster <- as.matrix(silhouette(clust_sub, distMat))   silWidthRC <- rbind(silWidthRC, silCluster) } spe2$rcSil <- silWidthRC[, 3] # for datasets with annotated cell type information, we can also calculate  # metrics like adjusted rand index (ARI) and normalised mutual information (NMI) as.data.frame(colData(spe2)) %>%   group_by(samples) %>%   summarise(ARI = aricode::ARI(Cell_class, reCluster),             NMI = aricode::NMI(Cell_class, reCluster),             ASW = mean(rcSil),             min_Entropy = min(entropy),             max_Entropy = max(entropy),             mean_Entropy = mean(entropy)) #> # A tibble: 4 × 7 #>   samples   ARI   NMI    ASW min_Entropy max_Entropy mean_Entropy #>   <fct>   <dbl> <dbl>  <dbl>       <dbl>       <dbl>        <dbl> #> 1 1.-0.09 0.341 0.501 0.0984       0.561        4.64         3.55 #> 2 1.0.16  0.436 0.563 0.0634       1.28         4.71         3.63 #> 3 7.-0.09 0.353 0.520 0.0887       0.211        4.64         3.55 #> 4 7.0.16  0.423 0.552 0.0824       0.211        4.68         3.58"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/MERFISH_mouseHypothalamus.html","id":"visualise-clustsignal-outputs","dir":"Articles","previous_headings":"","what":"Visualise clustSIGNAL outputs","title":"Multisample analysis","text":"entropy measures can useful assessing tissue composition samples - homogeneous (low entropy) domain-like regions, heterogeneous (high entropy) uniform distribution cells.  can also visualize spatial plot entropy distribution clusters, provide spatial context cells neighbourhoods, well compositions neighbouhoods.","code":"colors = c(\"#635547\", \"#8EC792\", \"#9e6762\", \"#FACB12\", \"#3F84AA\", \"#0F4A9C\",             \"#ff891c\", \"#EF5A9D\", \"#C594BF\", \"#DFCDE4\", \"#139992\", \"#65A83E\",             \"#8DB5CE\", \"#005579\", \"#C9EBFB\", \"#B51D8D\", \"#532C8A\", \"#8870ad\",             \"#cc7818\", \"#FBBE92\", \"#EF4E22\", \"#f9decf\", \"#c9a997\", \"#C72228\",             \"#f79083\", \"#F397C0\", \"#DABE99\", \"#c19f70\", \"#354E23\", \"#C3C388\",            \"#647a4f\", \"#CDE088\", \"#f7f79e\", \"#F6BFCB\", \"#7F6874\", \"#989898\",             \"#1A1A1A\", \"#FFFFFF\", \"#e6e6e6\", \"#77441B\", \"#F90026\", \"#A10037\",             \"#DA5921\", \"#E1C239\", \"#9DD84A\") # Histogram of entropy spread hst_ent <- as.data.frame(colData(spe2)) %>%   ggplot(aes(entropy)) +   geom_histogram(binwidth = 0.05) +   ggtitle(\"Entropy spread of regions\") +   facet_wrap(vars(samples), nrow = 1) +   labs(x = \"Entropy\", y = \"Number of regions\") +   theme_grey() +   theme(text = element_text(size = 12))  # Spatial plot showing sample entropy distribution spt_ent <- as.data.frame(colData(spe2)) %>%   ggplot(aes(x = spatialCoords(spe2)[, 1],               y = -spatialCoords(spe2)[, 2])) +   geom_point(size = 0.5,               aes(colour = entropy)) +   scale_colour_gradient2(\"Entropy\", low = \"grey\", high = \"blue\") +   scale_size_continuous(range = c(0, max(spe2$entropy))) +   facet_wrap(vars(samples), scales = \"free\", nrow = 1) +   ggtitle(\"Spatial distribution of region entropy\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   theme_classic() +   theme(text = element_text(size = 12))  hst_ent / spt_ent df_ent = as.data.frame(colData(spe2))  # spatial plot spt_clust <- df_ent %>%   ggplot(aes(x = spatialCoords(spe2)[, 1],               y = -spatialCoords(spe2)[, 2])) +   geom_point(size = 0.5, aes(colour = reCluster)) +   scale_color_manual(values = colors) +   facet_wrap(vars(samples), scales = \"free\", nrow = 1) +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   guides(color = guide_legend(title = \"Clusters\",                                override.aes = list(size = 3))) +   theme_classic() +   theme(text = element_text(size = 12))  box_clust = list() for (s in samplesList) {   df_ent_sub = as.data.frame(colData(spe2)[spe2[[samples]] == s, ])   # calculating median entropy of each cluster in a sample   celltype_ent = df_ent_sub %>%     group_by(as.character(reCluster)) %>%     summarise(meanEntropy = median(entropy))   # reordering clusters by their median entropy   # low to high median entropy   cellOrder = celltype_ent$meanEntropy   names(cellOrder) = celltype_ent$`as.character(reCluster)`   cellOrder = sort(cellOrder)   df_ent_sub$reCluster = factor(df_ent_sub$reCluster, levels = names(cellOrder))      # box plot of cluster entropy   colors_ent = colors[as.numeric(names(cellOrder))]   box_clust[[s]] <- df_ent_sub %>%     ggplot(aes(x = reCluster, y = entropy, fill = reCluster)) +     geom_boxplot() +     scale_fill_manual(values = colors_ent) +     facet_wrap(vars(samples), nrow = 1) +     labs(x = \"clustSIGNAL clusters\", y = \"Entropy\") +     ylim(0, NA) +     theme_classic() +     theme(legend.position = \"none\",           text = element_text(size = 12),           axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) }  spt_clust / (patchwork::wrap_plots(box_clust[1:4], nrow = 1) +                 plot_layout(axes = \"collect\")) +    plot_layout(guides = \"collect\") +   plot_annotation(title = \"Spatial and entropy distributions of clusters\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/seqFISH_mouseEmbryo.html","id":"seqfish-mouse-embryo-data-analysis","dir":"Articles","previous_headings":"","what":"SeqFISH mouse embryo data analysis","title":"Single sample analysis","text":"run clustSIGNAL, need column names sample cell labels colData dataframe spatial experiment object. , cell labels column ‘uniqueID’ sample labels ‘embryo’ column.","code":"# load required packages library(clustSIGNAL) library(distances) library(cluster) library(aricode) library(dplyr) library(ggplot2) library(patchwork) data(mouseEmbryo2) spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(2): counts logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(15): uniqueID embryo ... #>   segmentation_vertices_y_global_affine sample_id #> reducedDimNames(3): PCA UMAP spatial #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(0): names(colData(spe)) #>  [1] \"uniqueID\"                              #>  [2] \"embryo\"                                #>  [3] \"pos\"                                   #>  [4] \"z\"                                     #>  [5] \"x_global\"                              #>  [6] \"y_global\"                              #>  [7] \"embryo_pos\"                            #>  [8] \"embryo_pos_z\"                          #>  [9] \"Area\"                                  #> [10] \"UMAP1\"                                 #> [11] \"UMAP2\"                                 #> [12] \"celltype_mapped_refined\"               #> [13] \"segmentation_vertices_x_global_affine\" #> [14] \"segmentation_vertices_y_global_affine\" #> [15] \"sample_id\""},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/seqFISH_mouseEmbryo.html","id":"run-clustsignal","dir":"Articles","previous_headings":"","what":"Run clustSIGNAL","title":"Single sample analysis","text":"output variable list can contain dataframe cluster names, matrix NN neighbours cell, final spe object, combination , depending choice ‘outputs’ selected.","code":"set.seed(100) samples = \"embryo\" cells = \"uniqueID\" dimRed = \"PCA\" res_emb = clustSIGNAL(spe, samples, cells, dimRed, cluster.fun = \"leiden\", outputs = \"a\") #> [1] \"clustSIGNAL run started. 2024-07-25 08:22:10.886528\" #> [1] \"Initial nonspatial clustering performed. Clusters = 15 2024-07-25 08:22:18.077428\" #> [1] \"Nonspatial subclustering performed. Subclusters = 79 2024-07-25 08:22:24.306852\" #> [1] \"Regions defined. 2024-07-25 08:22:30.394411\" #> [1] \"Region domainness calculated. 2024-07-25 08:22:41.906502\" #> [1] \"Smoothing performed. NN = 30 Kernel = G Spread = 0.05 2024-07-25 08:25:37.687609\" #> [1] \"Nonspatial clustering performed on smoothed data. Clusters = 24 2024-07-25 08:25:43.857019\" #> [1] \"clustSIGNAL run completed. 2024-07-25 08:25:43.858958\" names(res_emb) #> [1] \"clusters\"   \"neighbours\" \"spe_final\" head(res_emb$clusters, n = 3) #>                      Cells Clusters #> 1  embryo2_Pos29_cell10_z2       20 #> 2  embryo2_Pos29_cell10_z5       20 #> 3 embryo2_Pos29_cell100_z2       20 spe = res_emb$spe_final spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(3): counts logcounts smoothed #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(19): uniqueID embryo ... entropy reCluster #> reducedDimNames(4): PCA UMAP spatial PCA.smooth #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(1): sample_id"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/seqFISH_mouseEmbryo.html","id":"calculate-clustering-metrics","dir":"Articles","previous_headings":"","what":"Calculate clustering metrics","title":"Single sample analysis","text":"","code":"# calculating silhouette width clusts <- as.numeric(as.character(spe$reCluster)) cXg_mat <- t(as.matrix(logcounts(spe))) distMat <- distances(cXg_mat) silCluster <- as.matrix(silhouette(clusts, distMat)) spe$rcSil <- silCluster[, 3]  # for datasets with annotated cell type information, we can also calculate  # metrics like adjusted rand index (ARI) and normalised mutual information (NMI) as.data.frame(colData(spe)) %>%   summarise(ARI = aricode::ARI(celltype_mapped_refined, reCluster),             NMI = aricode::NMI(celltype_mapped_refined, reCluster),             ASW = mean(rcSil),             min_Entropy = min(entropy),             max_Entropy = max(entropy),             mean_Entropy = mean(entropy)) #>         ARI       NMI        ASW min_Entropy max_Entropy mean_Entropy #> 1 0.2758015 0.5434374 0.02652979           0    3.124092      1.30814"},{"path":"https://sydneybiox.github.io/clustSIGNAL/articles/seqFISH_mouseEmbryo.html","id":"visualise-clustsignal-outputs","dir":"Articles","previous_headings":"","what":"Visualise clustSIGNAL outputs","title":"Single sample analysis","text":"entropy measures can useful assessing tissue composition samples - homogeneous (low entropy) domain-like regions, heterogeneous (high entropy) uniform distribution cells.  can also visualize spatial plot entropy distribution clusters, provide spatial context cells neighbourhoods, well compositions neighbouhoods.","code":"colors = c(\"#635547\", \"#8EC792\", \"#9e6762\", \"#FACB12\", \"#3F84AA\", \"#0F4A9C\",             \"#ff891c\", \"#EF5A9D\", \"#C594BF\", \"#DFCDE4\", \"#139992\", \"#65A83E\",             \"#8DB5CE\", \"#005579\", \"#C9EBFB\", \"#B51D8D\", \"#532C8A\", \"#8870ad\",             \"#cc7818\", \"#FBBE92\", \"#EF4E22\", \"#f9decf\", \"#c9a997\", \"#C72228\",             \"#f79083\", \"#F397C0\", \"#DABE99\", \"#c19f70\", \"#354E23\", \"#C3C388\",            \"#647a4f\", \"#CDE088\", \"#f7f79e\", \"#F6BFCB\", \"#7F6874\", \"#989898\",             \"#1A1A1A\", \"#FFFFFF\", \"#e6e6e6\", \"#77441B\", \"#F90026\", \"#A10037\",             \"#DA5921\", \"#E1C239\", \"#9DD84A\") # Histogram of entropy spread hst_ent <- as.data.frame(colData(spe)) %>%   ggplot(aes(entropy)) +   geom_histogram(binwidth = 0.05) +   ggtitle(\"Entropy spread of regions\") +   labs(x = \"Entropy\", y = \"Number of regions\") +   theme_grey() +   theme(text = element_text(size = 12))  # Spatial plot showing sample entropy distribution spt_ent <- as.data.frame(colData(spe)) %>%   ggplot(aes(x = spatialCoords(spe)[, 1],               y = -spatialCoords(spe)[, 2])) +   geom_point(size = 0.5,               aes(colour = entropy)) +   scale_colour_gradient2(\"Entropy\", low = \"grey\", high = \"blue\") +   scale_size_continuous(range = c(0, max(spe$entropy))) +   ggtitle(\"Spatial distribution of region entropy\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   theme_classic() +   theme(text = element_text(size = 12))  hst_ent + spt_ent df_ent = as.data.frame(colData(spe))  # spatial plot spt_clust <- df_ent %>%   ggplot(aes(x = spatialCoords(spe)[, 1],               y = -spatialCoords(spe)[, 2])) +   geom_point(size = 0.5, aes(colour = reCluster)) +   scale_color_manual(values = colors) +   ggtitle(\"Spatial distribution of clusters\") +   labs(x = \"x-coordinate\", y = \"y-coordinate\") +   guides(color = guide_legend(title = \"Clusters\",                                override.aes = list(size = 3))) +   theme_classic() +   theme(text = element_text(size = 12))  # calculating median entropy of each cluster celltype_ent = df_ent %>%   group_by(as.character(reCluster)) %>%   summarise(meanEntropy = median(entropy)) # reordering clusters by their median entropy # low to high median entropy cellOrder = celltype_ent$meanEntropy names(cellOrder) = celltype_ent$`as.character(reCluster)` cellOrder = sort(cellOrder) df_ent$reCluster = factor(df_ent$reCluster, levels = names(cellOrder)) # box plot of cluster entropy colors_ent = colors[as.numeric(names(cellOrder))] box_clust <- df_ent %>%   ggplot(aes(x = reCluster, y = entropy, fill = reCluster)) +   geom_boxplot() +   scale_fill_manual(values = colors_ent) +   ggtitle(\"Entropy ditribution of clusters\") +   labs(x = \"clustSIGNAL clusters\", y = \"Entropy\") +   theme_classic() +   theme(legend.position = \"none\",         text = element_text(size = 15),         axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))  spt_clust + box_clust + patchwork::plot_layout(guides = \"collect\", widths = c(1, 2))"},{"path":"https://sydneybiox.github.io/clustSIGNAL/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Pratibha Panwar. Maintainer.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"c), person), person), person), person) (2024). clustSIGNAL: clustSIGNAL: spatial clustering method. R package version 0.1.0, https://sydneybiox.github.io/clustSIGNAL/.","code":"@Manual{,   title = {clustSIGNAL: clustSIGNAL: a spatial clustering method},   author = {{c)} and {person)} and {person)} and {person)} and {person)}},   year = {2024},   note = {R package version 0.1.0},   url = {https://sydneybiox.github.io/clustSIGNAL/}, }"},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"clustsignal","dir":"","previous_headings":"","what":"clustSIGNAL: a spatial clustering method","title":"clustSIGNAL: a spatial clustering method","text":"clustSIGNAL: clustering Spatially Informed Gene expression Neighbourhood Adapted Learning. R package perform spatial clustering spatially-resolved transcriptomics datasets. , calculate entropy measure “domainness” cell neighbourhoods, use generate weight distributions perform adaptive smoothing gene expression. Homogeneous neighbourhoods low entropy, , smoothing performed cells neighbourhoods. Contrarily, heterogeneous neighbourhoods high entropy smoothed much smaller region. approach overcomes data sparsity gene expression also incorporates spatial context form cell arrangement information neighbourhood. resulting adaptively smoothed gene expression used downstream analyses like clustering.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"clustSIGNAL: a spatial clustering method","text":"can install clustSIGNAL package GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"SydneyBioX/clustSIGNAL\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"clustsignal-parameters","dir":"","previous_headings":"","what":"clustSIGNAL parameters","title":"clustSIGNAL: a spatial clustering method","text":"clustSIGNAL package uses SpatialExperiment object input. provide users number parameters explore experiment , well prior tested default values quick runs. clustSIGNAL can used single sample multisample analysis just one function call. list parameters offered possible values: spe - SpatialExperiment object cell spatial coordinates spatialCoords matrix. samples - column name cell metadata containing sample names. cells - column name cell metadata containing cell IDs. dimRed - dimensionality reduction method name low embedding data. Default “None”, case PCA calculated used reduced dimensions data. NN - neighbourhood size terms number nearest neighbours consider. Value > 1. Default value 30. kernel - type weight distribution use. Can Gaussian (default) exponential distribution. spread - value distribution parameter - standard deviation Gaussian distribution rate exponential distribution. Default value 0.05, recommended Gaussian distribution. exponential distribution, recommended value 20. sort - whether cell neighbourhoods sorted ‘putative cell type’ grouping. Default value True. threads - number cpus use parallel runs. Default value 1. outputs - choice output types. Default value ‘c’ data frame cell IDs cluster numbers. possible values include - ‘n’ list data frame clusters matrix neighbourhood cell IDs, ‘s’ list data frame clusters final SpatialExperiment object, ‘’ list 3 outputs. … - additional options non-spatial clustering algorithms bluster package, e.g., KmeansParam options like centers iter.max, NNGraphParam options like k cluster.fun.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/index.html","id":"running-clustsignal","dir":"","previous_headings":"","what":"Running clustSIGNAL","title":"clustSIGNAL: a spatial clustering method","text":"running clustSIGNAL, important ensure SpatialExperiment object input spatial coordinates stored spatialCoords matrix. Otherwise, method throw error asking user provide spatial coordinates.","code":"# load required packages library(clustSIGNAL)  data(mouseEmbryo2) spe  # Here, the cell labels are in the column 'uniqueID' and sample labels are in 'embryo' column.  set.seed(100) res = clustSIGNAL(spe, samples = \"embryo\", cells = \"uniqueID\", dimRed = \"PCA\", cluster.fun = \"leiden\", outputs = \"a\")"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive smoothing — adaptiveSmoothing","title":"Adaptive smoothing — adaptiveSmoothing","text":"function perform weighted, adaptive smoothing gene expression based heterogeneity cell neighbourhood. Heterogeneous neighbourhoods smoothed less higher weights given cells belonging initial group. Homogeneous neighbourhoods smoothed similar weights given cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive smoothing — adaptiveSmoothing","text":"","code":"adaptiveSmoothing(spe, nnCells, NN, kernel, spread)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive smoothing — adaptiveSmoothing","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups, entropy outputs included. nnCells character matrix NN nearest neighbours - rows cells columns nearest neighbours ranged closest farthest neighbour. sort = TRUE, neighbours belonging 'putative cell type' group cell moved closer . NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. kernel character type distribution used. two valid values \"G\" \"E\". G Gaussian distribution, E exponential distribution. Default value \"G\". spread numeric value distribution spread, represented standard deviation Gaussian distribution rate exponential distribution. Default value 0.05 Gaussian distribution 20 exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive smoothing — adaptiveSmoothing","text":"SpatialExperiment object including smoothed gene expression values another assay.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/adaptiveSmoothing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive smoothing — adaptiveSmoothing","text":"","code":"data(mouseEmbryo2)  # requires matrix containing NN nearest neighbour cell labels (nnCells), # generated using the neighbourDetect() function spe <- adaptiveSmoothing(spe, nnCells, NN = 30, kernel = \"G\", spread = 0.05) #> Error in seq.default(0, ed, length.out = NN): 'to' must be of length 1 spe #> class: SpatialExperiment  #> dim: 351 14891  #> metadata(0): #> assays(2): counts logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(14891): embryo2_Pos29_cell10_z2 embryo2_Pos29_cell10_z5 ... #>   embryo2_Pos50_cell99_z2 embryo2_Pos50_cell99_z5 #> colData names(15): uniqueID embryo ... #>   segmentation_vertices_y_global_affine sample_id #> reducedDimNames(3): PCA UMAP spatial #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_global_affine y_global_affine #> imgData names(0):"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":null,"dir":"Reference","previous_headings":"","what":"clustSIGNAL — clustSIGNAL","title":"clustSIGNAL — clustSIGNAL","text":"clustering method cell type classification spatial transcriptomics data. tool generates uses adaptively smoothed, spatially informed gene expression data clustering.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"clustSIGNAL — clustSIGNAL","text":"","code":"clustSIGNAL(   spe,   samples,   cells,   dimRed = \"None\",   NN = 30,   kernel = \"G\",   spread = 0.05,   sort = TRUE,   threads = 1,   outputs = \"c\",   ... )"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"clustSIGNAL — clustSIGNAL","text":"spe SpatialExperiment object. samples character indicating name colData(spe) column containing sample names. cells character indicating name colData(spe) column containing cell IDs. dimRed character indicating name reduced dimensions use SpatialExperiment object (.e., reducedDimNames(spe)). Default value 'PCA'. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. kernel character type distribution used. two valid values \"G\" \"E\". G Gaussian distribution, E exponential distribution. Default value \"G\". spread numeric value distribution spread, represented standard deviation Gaussian distribution rate exponential distribution. Default value 0.05 Gaussian distribution 20 exponential distribution. sort logical parameter whether sort neighbourhood region description. Default value TRUE. threads numeric value number CPU cores used analysis. Default value set 4 cores. outputs character type output return user. \"c\" data frame cell IDs respective cluster numbers (default), \"n\" list dataframe clusters plus neighbourhood matrix, \"s\" list dataframe clusters plus final spatialExperiment object, \"\" list outputs. ... additional parameters TwoStepParam clustering methods. Include parameters like k number nearest neighbours cluster.fun selecting community detection method. Default values k = 5, cluster.fun = \"louvain\".","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"clustSIGNAL — clustSIGNAL","text":"list outputs 1. clusters: data frame cell names cluster classification. 2. neighbours: matrix cell names names NN nearest neighbour cells. 3. spe_final: SpatialExperiment object initial 'putative cell type' groups, entropy values, smoothed gene expression, post-smoothing clusters, silhouette widths included.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/clustSIGNAL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"clustSIGNAL — clustSIGNAL","text":"","code":"data(mouseEmbryo2)  names(colData(spe)) #>  [1] \"uniqueID\"                              #>  [2] \"embryo\"                                #>  [3] \"pos\"                                   #>  [4] \"z\"                                     #>  [5] \"x_global\"                              #>  [6] \"y_global\"                              #>  [7] \"embryo_pos\"                            #>  [8] \"embryo_pos_z\"                          #>  [9] \"Area\"                                  #> [10] \"UMAP1\"                                 #> [11] \"UMAP2\"                                 #> [12] \"celltype_mapped_refined\"               #> [13] \"segmentation_vertices_x_global_affine\" #> [14] \"segmentation_vertices_y_global_affine\" #> [15] \"sample_id\"                             # identify the column names with cell and sample labels samples = \"embryo\" cells = \"uniqueID\" res_list <- clustSIGNAL(spe, samples, cells, dimRed = \"PCA\", outputs = \"c\") #> [1] \"clustSIGNAL run started. 2024-07-25 08:14:23.342451\" #> [1] \"Initial nonspatial clustering performed. Clusters = 14 2024-07-25 08:14:30.414454\" #> [1] \"Nonspatial subclustering performed. Subclusters = 78 2024-07-25 08:14:35.853681\" #> [1] \"Regions defined. 2024-07-25 08:14:42.455327\" #> [1] \"Region domainness calculated. 2024-07-25 08:14:53.461301\" #> [1] \"Smoothing performed. NN = 30 Kernel = G Spread = 0.05 2024-07-25 08:17:47.383725\" #> [1] \"Nonspatial clustering performed on smoothed data. Clusters = 25 2024-07-25 08:17:53.586004\" #> [1] \"clustSIGNAL run completed. 2024-07-25 08:17:53.587966\""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell neighbourhood composition — .calculateProp","title":"Cell neighbourhood composition — .calculateProp","text":"function calculate cell neighbourhood composition 'putative' cell types.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell neighbourhood composition — .calculateProp","text":"","code":".calculateProp(arr)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell neighbourhood composition — .calculateProp","text":"arr vector 'putative cell type' assignments cell neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-calculateProp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell neighbourhood composition — .calculateProp","text":"table 'putative cell type' proportions neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell naming — .cellName","title":"Neighbour cell naming — .cellName","text":"function fetch cell IDs.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell naming — .cellName","text":"","code":".cellName(cell, Clust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell naming — .cellName","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. Clust data frame initial cluster assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellName.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell naming — .cellName","text":"data frame cell IDs neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell sorting — .cellNameSort","title":"Neighbour cell sorting — .cellNameSort","text":"function perform neighbourhood cell sorting. Neighbourhood cells belong 'putative cell type' central cell moved closer central cell.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell sorting — .cellNameSort","text":"","code":".cellNameSort(cell, Clust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell sorting — .cellNameSort","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. Clust data frame initial cluster assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-cellNameSort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell sorting — .cellNameSort","text":"data frame cell IDs sorted neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbour cell 'putative cell type' assignment — .clustNum","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"function fetch 'putative cell type' assignments cell.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"","code":".clustNum(cell, subClust)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"cell vector neighbourhood cell indices. cell indices indicate row number cells sample metadata. subClust data frame 'putative cell type' assignments cells sample.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-clustNum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbour cell 'putative cell type' assignment — .clustNum","text":"data frame 'putative cell type' assignments neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential distribution weights — .exp_kernel","title":"Exponential distribution weights — .exp_kernel","text":"function generate weights exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential distribution weights — .exp_kernel","text":"","code":".exp_kernel(ed, NN, rate)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential distribution weights — .exp_kernel","text":"ed numeric value entropy neighbourhood. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. rate numeric value rate exponential distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-exp_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential distribution weights — .exp_kernel","text":"numeric vector weights.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian distribution weights — .gauss_kernel","title":"Gaussian distribution weights — .gauss_kernel","text":"function generate weights Gaussian distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian distribution weights — .gauss_kernel","text":"","code":".gauss_kernel(ed, NN, sd)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian distribution weights — .gauss_kernel","text":"ed numeric value entropy neighbourhood. NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. sd numeric value standard deviation Gaussian distribution.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-gauss_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian distribution weights — .gauss_kernel","text":"numeric vector weights.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":null,"dir":"Reference","previous_headings":"","what":"Smoothing per neighbourhood — .smoothedData","title":"Smoothing per neighbourhood — .smoothedData","text":"function perform weighted moving average gene expression neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smoothing per neighbourhood — .smoothedData","text":"","code":".smoothedData(mat, weight)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smoothing per neighbourhood — .smoothedData","text":"mat gene expression matrix genes rows neighbourhood cells columns. weight column matrix weights, number rows equal number neighbourhood cells.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/dot-smoothedData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smoothing per neighbourhood — .smoothedData","text":"column matrix smoothed gene expression.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":null,"dir":"Reference","previous_headings":"","what":"Domainness measure — entropyMeasure","title":"Domainness measure — entropyMeasure","text":"function measure heterogeneity cell's neighbourhood terms entropy, homogeneous neighbourhoods low entropy heterogeneous neighbourhoods high entropy.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Domainness measure — entropyMeasure","text":"","code":"entropyMeasure(spe, cells, regXclust, threads)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Domainness measure — entropyMeasure","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups included. cells character vector cell IDs cell. Length vector must equal number cells spatialExperiment object (.e. number rows colData(spe)). regXclust list vectors cell's neighbourhood composition indicated proportion 'putative cell type' groups contains. threads numeric value number CPU cores used analysis.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Domainness measure — entropyMeasure","text":"SpatialExperiment object including entropy values cell neighbourhood.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/entropyMeasure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Domainness measure — entropyMeasure","text":"","code":"data(mouseEmbryo2)  # requires list of containing cluster proportions of each region (regXclust), # generated using the neighbourDetect() function spe <- entropyMeasure(spe, cells = \"uniqueID\", regXclust, threads = 1) #> Error in eval(expr, envir, enclos): object 'regXclust' not found head(spe$entropy) #> NULL"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell neighbourhood detection — neighbourDetect","title":"Cell neighbourhood detection — neighbourDetect","text":"function identify neighbourhood cell. sort = TRUE, neighbourhoods also sorted cells belonging group central cell arranged closer .","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell neighbourhood detection — neighbourDetect","text":"","code":"neighbourDetect(spe, samples, NN, cells, sort)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell neighbourhood detection — neighbourDetect","text":"spe SpatialExperiment object logcounts, PCA, 'putative cell type' groups included. samples character vector sample names cells belong. Length vector must equal number cells spatialExperiment object (.e. number rows colData(spe)). NN integer number neighbourhood cells function consider. value must greater equal 1. Default value 30. cells character vector cell IDs cell. Length vector must equal number cells SpatialExperiment object (.e. number rows colData(spe)). sort logical parameter whether sort neighbourhood region description. Default value TRUE.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell neighbourhood detection — neighbourDetect","text":"list containing two items: 1. nnCells, character matrix NN nearest neighbours - rows cells columns nearest neighbours ranged closest farthest neighbour. sort = TRUE, neighbours belonging 'putative cell type' group cell moved closer . 2. regXclust, list vectors cell's neighbourhood composition indicated proportion 'putative cell type' groups contains.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/neighbourDetect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell neighbourhood detection — neighbourDetect","text":"","code":"data(mouseEmbryo2)  out_list <- neighbourDetect(spe, samples = \"embryo\", NN = 30, cells = \"uniqueID\", sort = TRUE) #> Error in `.rowNamesDF<-`(x, value = value): invalid 'row.names' length names(out_list) #> Error in eval(expr, envir, enclos): object 'out_list' not found"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-spatial clustering — nsClustering","title":"Non-spatial clustering — nsClustering","text":"function containing two steps used different times clustSIGNAL workflow. initial non-spatial clustering sub-clustering step (reclust = FALSE) used generate groups ‘putative cell types’, whereas later non-spatial clustering step (reclust = TRUE) used cluster adaptively smoothed gene expression data.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-spatial clustering — nsClustering","text":"","code":"nsClustering(spe, dimRed, reclust, ...)"},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-spatial clustering — nsClustering","text":"spe SpatialExperiment object. reclust = FALSE, object contain logcounts PCA, reculst = TRUE, object contain smoothed gene expression. reclust logical parameter handled within method.","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-spatial clustering — nsClustering","text":"SpatialExperiment object containing 'putative cell type' group allotted cell (reclust = FALSE) clusters generated smoothed data (reclust = TRUE).","code":""},{"path":"https://sydneybiox.github.io/clustSIGNAL/reference/nsClustering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-spatial clustering — nsClustering","text":"","code":"data(mouseEmbryo2)  # for non-spatial clustering of normalised counts spe <- nsClustering(spe, dimRed = \"PCA\", reclust = FALSE) #> [1] \"Initial nonspatial clustering performed. Clusters = 14 2024-07-25 08:18:02.894655\" #> [1] \"Nonspatial subclustering performed. Subclusters = 81 2024-07-25 08:18:07.430886\" head(spe$nsCluster) #> [1] 6 6 6 6 7 6 #> Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 head(spe$nsSubcluster) #>  embryo2_Pos29_cell10_z2  embryo2_Pos29_cell10_z5 embryo2_Pos29_cell100_z2  #>                    \"6.3\"                    \"6.5\"                    \"6.5\"  #> embryo2_Pos29_cell100_z5 embryo2_Pos29_cell101_z2 embryo2_Pos29_cell101_z5  #>                    \"6.5\"                    \"7.2\"                    \"6.5\"   # for non-spatial clustering of adaptively smoothed counts spe <- nsClustering(spe, dimRed = \"PCA\", reclust = TRUE) #> Error in assay(x, assay.type): 'assay(<SpatialExperiment>, i=\"character\", ...)' invalid subscript 'i' #> 'smoothed' not in names(assays(<SpatialExperiment>)) head(spe$reCluster) #> NULL"}]
